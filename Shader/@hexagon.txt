// xs_begin
// author : 'malinfei'
// arg : { name = 'Mode'  var = 'm_mode'  range = '0 2'  value = '0'  step = '1'  precision = '0' }
// arg : { name = 'AltColor'  var = 'm_alt_color'  range = '0 255'  value = '0'  step = '1'  precision = '0' }
// arg : { name = 'Radius'  var = 'm_radius'  range = '4 127'  value = '11'  step = '2'  precision = '0' }
// arg : { name = 'Rotation'  var = 'm_ration'  range = '0 3'  value = '0'  step = '1'  precision = '0' }
// xs_end

int mode = int(m_mode);											// 0: fill volume using AltColor on border, 1: fill volume using AltColor on inside, 2: only one
int radius = int(floor(m_radius * 0.5) * 2 + 1);				// not include center, require odd number
int rot = int(m_ration);
// runtime
int diameter = radius * 2;										// not include center
float step = 0.5;												// step = 2
int minLineSize = int((radius - floor(radius * step)) * 2 + 1);
int yOffset = diameter + minLineSize - 1;
float borderColor = mode == 0 ? float(m_alt_color) : i_color_index;
float fillColor = mode == 0 ? i_color_index : float(m_alt_color);

float CalcHexagon(vec3 volume_size, vec3 v)
{
	vec2 c = mode == 2 ? vec2(radius, radius) : vec2(floor(v.x / diameter) * diameter + radius, floor(v.y / yOffset) * yOffset + radius);
	float x = floor(v.x);										// v is at the center of voxel, such as vec3( 1.5, 2.5, 4.5 )
	float y = floor(v.y);
	float x2c = abs(x - c.x);
	float y2c = abs(y - c.y);
	if (x2c <= radius && y2c <= radius - floor(x2c * step))
	{
		// 0: border, 1: inside
		return x2c == radius || y2c == radius - floor(x2c * step) ? borderColor : fillColor;
	}
	else if (mode != 2)
	{
		return mod(x - radius, diameter) == 0 ? borderColor : fillColor;
	}
	return 0.f;
}

float map(vec3 v) 
{
	if (rot == 0) 
	{
		return CalcHexagon(i_volume_size.yxz, v.yxz);
	}
	else if (rot == 1) 
	{
		return CalcHexagon(i_volume_size, v);
	} 
	else if (rot == 2) 
	{
		return CalcHexagon(i_volume_size.zxy, v.zxy);
	} 
	else if (rot == 3) 
	{
		return CalcHexagon(i_volume_size.zyx, v.zyx);
	}
}
